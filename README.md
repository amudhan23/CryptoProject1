
	In this project, we were tasked to decrypt an encrypted text generated by the Mono-alphabetic substitution Cipher with random insertion of characters to confuse eavesdroppers. In addition, we must consider an extra character, space, into the set of acceptable encrypted characters. As a result, this proved to make letter frequency approach quite cumbersome, as spaces are quite prevalent in English sentences. There is very little information or existing statistics for the percentage of space occurring in English in respect to the English alphabet. As such, we then looked into possibilities for utilizing bigrams, trigrams, and quadgrams to identify patterns in the encrypted text, which we later learned about Hill’s Algorithm. In this algorithm, we first generate a uniformly randomly selected key and decrypt the text based on this key. After doing so, we integrate a fitness measure (score) functionality to numerically evaluate the accuracy of how the decrypted text resembles common english patterns in respect to bigrams, trigrams, and quadgrams. More specifically, we obtain the probability of English patterns occurring in respect to each ngrams and get the summation of each ngrams to obtain a fitness measure of the current decrypted text. We got this inspiration from the Genetic Algorithm research article to obtain an equation for the fitness measure as the summation of each n-grams probability for english resemblance with weights alpha, beta, and gamma for bigrams, trigrams, and quadgrams respectively. In our implementation, we chose alpha, beta, and gamma to be 0.6, 0.9, and 1 respectively. Our intuition behind this decision is to consider that a larger n-grams has a higher indicator that the corresponding text is related to English text and is based on assumptions in existing literature. Based on our analysis, this seems to hold true to an extent and a deeper analysis to find the most optimized weights would be desirable. In our implementation, we generate independently randomly selected keys 150 times ( representing the amount of hills ) and for each key generate a score representing the fitness measure and adjust the key by randomly selecting 2 indices in the key to switch in an effort to improve the score and find a better fitting key. This procedure represents climbing the hill until we reach a local maximum and randomly selecting keys, which is done 2500 times. This enables us to improve the odds of finding the best path leading towards the global maximum. With the introduction of possible random characters and the integration of randomness, we decided to utilize Levenshtein’s distance algorithm to determine the best fitting plaintext in respect to our final guess text. Levenshtein’s distance algorithm finds the minimum operations required to equate two strings, which helps us choose the best fitting plain text answer based on the minimum operations, or in other words, selects the most similar plain text.
 
	In this decryption scheme, we implemented Hill’s algorithm to find the encrypted plain text through local maximums. To be more specific, we first take the encrypted text and pass it to our OuterHill function where we run 150 iterations, generating random permutative keys. Through this we call the RandomKey function which generates the best permutative random key for that iteration, which then calls the innerHill function. In this function, this is where most of the logic lies, where we do random swaps between indices for the current key if we are unable to improve the fitness score. Throughout this process we track the score, and then update the key accordingly if it obtains a better fitness measure as seen below in the pseudo-code:
	innerHill
	best_key = Random initialized key
	best_score
	for i between 1...2500:
		Pick two random indices random_i, random_j for copy_best_k
		copy_best_key[random_i], copy_best_key[random_j] = copy_best_key[random_j], copy_best_key[random_i]
		score = calculate_score(copy_best_key)
		If score is better then best_score:
		best_score = score
		best_key = copy_best_key
	The score function is obtained by taking the Summation of bigrams, trigrams, and quadgrams respectively with their respective weights as seen below:
	Alpha * Summation( prob(bigrams)) + Beta * Summation (prob(trigrams)) + gamma * Summation (prob(quadgrams))
	After going through all possible iterations we then use the most optimal key obtained from our algorithm to decrypt the message and then apply the Levenshtein distance formula to find out which plain text it resembles the most.


